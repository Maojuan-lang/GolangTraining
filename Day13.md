# Golang

---

## 结构体

Golang语言面向对象编程说明：

1. Golang也支持面向对象编程（OOP），但是和传统的面向对象编程有区别，并不是纯粹的面向对象语言。所以我们说Golang支持面向对象编程特性是比较准确的
2. Golang没有类（class），Go语言的结构体（struct）和其他编程语言的类（class）有同等的地位
3. Golang面向对象编程非常简洁，去掉了传统的OOP语言的继承、方法重载、构造函数、析构函数和隐藏的this指针等等
4. Golang仍有面向对想编程的继承、封装和多态的特性，只是实现的方式和其他的OOP语言不一样
5. OOP本身就是语言类型系统的一部分，通过接口关联，耦合性低，非常灵活。

结构体和结构体变量的区别和联系：

1. 结构体是自定义的数据类型，代表一类事物
2. 结构体变量是具体的，实际的，代表一个具体变量

如何声明结构体

```go
type 结构体名称 struct{
    field1 type
    field2 type
}
```

字段/属性

1. 从概念或叫法上看，结构体字段=属性=field
2. 字段是结构体的一个组成部分，一般是基本数据类型、数组，也可是引用类型
3. 在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值（默认值），布尔类型是false，整形是0，字符串是""。数组类型的默认值跟他的元素类型相关。
4. 不同结构体变量的字段是独立的，互不影响，一个人结构体变量字段的更改，不影响另外一个

创建结构体变量和访问结构体字段：

1. 方式一：直接声明

   var person Person

2. 方式二：{}

   var person Person = Person{}

3. 方式三：&

   var person *Person = new (Person)

4. 方式四：{}

   var person *Person = &Person{}

注意事项：

1. 第三种和第四种方式返回的是结构体指针
2. 结构体指针访问字段的标准方式应该是：(*结构体指针).字段名
3. go的简化：结构体指针.字段名

结构体的注意事项和使用细节：

1. 结构体的所有字段在内存中是连续分配的
2. 结构体是用户单独定义的类型，和其他类型进行转换时需要有完全相同的字段（名字，个数，类型）
3. 结构体进行type重新定义（相当于取别名），Golang认为是新的数据类型，但是相互之间可以强转
4. struct的每个字段上可以写上一个tag，该tag可以通过反射机制获取，常见的使用场景就是序列化和反序列化（例子：name string 'json:stuName'）

---

## 方法

基本介绍：Golang中的方法是作用在指定的数据类型上的（即：和指定的数据类型绑定），因此自定义类型都可以有方法，而不仅仅是struct  

方法是声明和调用

```go
type A struct{
    Num int
}
func (a A) test(){
    fmt.Println(a.Num)
}

var t A
t.test()
```

方法的调用和传参机制原理

基本介绍：

1. 方法的调用和传参机制和函数一样
2. 不一样的地方是方法调用时，会将调用方法的变量当作实参也传递给方法（如果变量是值类型，则进行值拷贝。如果变量是引用类型，则进行地址拷贝）

方法的声明（定义）

```go
func (recevier type) methodName(参数列表) (返回值类型){
    方法体
    return 返回值
}
```

1. 参数列表：表示方法输入
2. receiver type：表示这个方法和type这个类型进行绑定，或者说该方法作用于type类型
3. receiver type：type可以是结构体，也可以是其他的自定义类型
4. receiver：就是type类型的一个变量（实例），比如：Person结构体的一个变量（实例）
5. 参数列表，表示方法输入
6. 返回值列表，表示返回的值，可以多个
7. 方法主体，表示为了实现某一功能的代码块
8. return语句不是必须的

注意事项：

1. 结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式
2. 如程序员希望在方法中修改结构体变量的值，可以通过结构体指针的方式来处理
3. Golang中的方法作用在指定的数据类型上的（即：和指定的数据类型绑定），因此自定义类型都可以有方法，而不仅仅是struct
4. 方法的访问范围控制的规则和函数一样，方法名首字母小写，只能在本地包访问，方法名首字母大写，可以在本地包和其他包访问
5. 如果一个变量实现了String()这个方法，那么fmt.Println默认会调用这个变量的String()进行输出

---

## 方法和函数的区别

1. 调用方式不一样
   1. 函数的调用方式：函数名（实参列表）
   2. 方法的调用方式：变量.方法名（实参列表）
2. 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然
3. 对于方法，接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样可以

---

## 创建结构体变量的时候直接指定字段值

基本介绍：Golnag在创建结构体实例（变量）时，可以直接指定字段的值

创建结构体变量时指定字段值方式：

1. 方式一：

   1. var stu Student = Student{"Da Ming", 21}

   2. stu2 := Student{"Da Ming", 21}

   3. var stu3 Student = Student{

      ​	name : "Da Ming",

      ​	age : "21",

      }

   4. stu4 := Student{

      ​	name : "Da Ming",

      ​	age : "21",

      }

2. 方式二：

   1. var stu5 *Student = &Student{"Daming",21}

   2. var stu6 *Student = &Student{

      ​	name : "Da Ming",

      ​	age : "21",

      }

---

## 工厂模式

基本介绍：Golang的结构体没有构造函数，通常可以使用工厂模式来解决这个问题

参考：java中bean的使用

---

## 面向对象编程三大特性

基本介绍：Golang仍有面向对象编程的继承、封装和多态的特性，只是实现的方式和其他OOP语言不一样

封装介绍：封装（encapsulation）就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作

封装的理解和好处：

1. 隐藏实现细节
2. 可以对数据进行验证，保证安全合理

如何体现封装：

1. 对数据体中的属性进行封装
2. 通过方法、包实现封装

封装的实现步骤：

1. 将结构体、字段（属性）的首字母小写
2. 给结构体所在的包提供一个工厂模式的函数，首字母大写
3. 提供一个首字母大写的Set方法，用于对属性判断并赋值
4. 提供一个首字母大写的Get方法，用于获取属性的值

---

## 面向对象编程-继承

继承基本介绍：继承可以解决代码复用，让我们的编程更佳靠近人类思维。当多个结构体存在相同的属性（字段）和方法时，可以从这些结构体中抽象出结构体，在该结构体中定义这些相同的属性和方法。其他的结构体不需要重新定义这些属性和方法，只需嵌套一个Student匿名结构即可

继承的深入讨论：

1. 结构体可以使用嵌套匿名结构体所有的字段和方法
2. 匿名结构体字段访问可以简化
3. 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分
4. 结构体嵌入两个（或多个）匿名结构体，如果两个匿名结构体都有相同的字段和方法，在访问时就必须就必须明确指明匿名结构体名字，否则编译器报错
5. 如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，就必须带上结构体的名字
6. 嵌套匿名结构体后，也可以在创建结构体变量时，直接指定各个匿名结构体字段的值

多重继承的注意事项：

1. 如嵌入的匿名结构体有相同的字段名或者方法名，则在访问时，需要通过匿名结构体类型名来区分
2. 为了保证代码的简洁性，建议尽量不使用多重继承

---

## 接口

基本介绍：interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。某个自定义类型要使用的时候，再根据具体情况把这些方法写出来

基本语法：

```
type 接口名 interface{
    method1(参数列表) 返回值类型
    method2(参数列表) 返回值类型
    ...
}

func (t 自定义类型) method1(参数列表) 返回值列表{
    //方法实现
}

func (t 自定义类型) method2(参数列表) 返回值列表{
    //方法实现
}
//...
```

注意事项：

1. 接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法，接口体现了程序设计的多态和高内聚低耦合的思想
2. Golang中的接口，不需要显式的实现。只要一个变量，含有接口类型的所有方法，那么这个变量就实现这个接口。因此，Golang中没有implement这样的关键字
3. 接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）
4. 接口中所有的方法都没有方法体，即都是没有实现的方法
5. 在Golang中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现了该接口
6. 一个自定义类型只有实现了某个接口，才能将该自定义类型的实例（变量）赋给接口类型
7. 只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型
8. 一个自定义类型可以实现多个接口
9. Golang接口中不能有任何变量
10. 一个接口可以继承多个别的接口，这时如果要实现其中一个接口，也必须将其它接口的方法全部实现。
11. interface类型默认是一个指针，如果没有对interface初始化就使用会输出nil
12. 空接口interface没有任何方法，所以所有类型都实现了空接口

---

## 实现接口和继承

1. 接口和继承解决的问题不同
   1. 继承的价值主要在于：解决代码的复用性和可维护性
   2. 接口的价值主要在于：设计，设计好各种规范（方法），让其他自定义类型去实现这些方法
2. 接口比继承更加灵活
   1. 接口比继承更加灵活，继承是满足is - a的关系，而接口只需满足like - a的关系
3. 接口在一定程度上实现代码解耦

---

## 面向对象编程-多态

基本介绍：变量具有多种形态。面向对象的第三大特征，在Go语言中，多态特征是通过接口是闲的。可以按照统一的接口来调用不通的实现。这时接口变量就呈现不同的形态。

接口体现多态特征：

1. 多态参数
2. 多台数组

---

## 类型断言

